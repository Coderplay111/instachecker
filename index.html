<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Instagram Downloader — Blob Auto-Download</title>
  <style>
    body{font-family:system-ui,Arial;margin:20px;background:#fafafa;color:#111}
    .wrap{max-width:820px;margin:0 auto}
    input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid #ccc;margin:8px 0}
    button{background:#e1306c;color:#fff;border:none;padding:10px 16px;border-radius:8px;cursor:pointer}
    .status{margin-top:12px}
    pre{background:#121217;color:#cfe; padding:12px;border-radius:8px;overflow:auto;max-height:280px}
    .result{margin-top:18px;padding:12px;background:#fff;border-radius:10px;border:1px solid #eee}
    .thumb{max-width:160px;border-radius:6px;margin-right:12px;vertical-align:middle}
    .flex{display:flex;gap:12px;align-items:flex-start}
    a.fallback{display:inline-block;margin-top:8px;background:#28a745;color:#fff;padding:8px 12px;border-radius:8px;text-decoration:none}
    .note{font-size:13px;color:#555;margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Instagram Video Downloader (Blob auto-download)</h2>
    <p class="note">Paste an Instagram post/reel URL and click Download. If automatic download fails due to CORS, a direct link will be provided.</p>

    <input id="url" type="text" placeholder="https://www.instagram.com/reel/C1U6tQLu1vv/" />
    <div style="display:flex;gap:8px">
      <button id="btn">Download</button>
      <button id="clear">Clear</button>
    </div>

    <div class="status" id="status"></div>

    <div class="result" id="result" style="display:none">
      <div id="mediaArea"></div>
      <div id="raw"></div>
    </div>

    <h3 style="margin-top:20px">Debug / Last API response</h3>
    <pre id="debug">{}</pre>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
  // ====== CONFIG ======
  const RAPIDAPI_HOST = 'all-in-one-downloader6.p.rapidapi.com';
  // Replace with your key for local testing. Don't expose this key in production.
  const RAPIDAPI_KEY = 'db2704b9e4msh5f98d0d57ab9dacp19c03ejsn9bd899a1b326';
  const RAPIDAPI_ENDPOINT = 'https://all-in-one-downloader6.p.rapidapi.com/';

  // ====== UTIL ======
  function setStatus(msg, isError = false) {
    const s = document.getElementById('status');
    s.textContent = msg;
    s.style.color = isError ? '#b00020' : '#111';
  }

  function pretty(obj) {
    return JSON.stringify(obj, null, 2);
  }

  // find any URL-like string in an object (recursively) that looks like a video
  function extractUrls(obj) {
    const urls = new Set();
    const isUrl = (s) => typeof s === 'string' && /https?:\/\/[^\s'"]+/.test(s);
    function walker(x) {
      if (!x) return;
      if (typeof x === 'string') {
        if (isUrl(x)) urls.add(x);
        return;
      }
      if (Array.isArray(x)) {
        x.forEach(walker);
        return;
      }
      if (typeof x === 'object') {
        for (const k in x) {
          const v = x[k];
          if (typeof v === 'string' && isUrl(v) && /\.(mp4|m3u8|mp3|webm)/i.test(v)) {
            urls.add(v);
          } else {
            walker(v);
          }
        }
      }
    }
    walker(obj);
    // fallback: include any generic https URLs if we didn't find mp4s
    if (urls.size === 0) {
      function walker2(x) {
        if (!x) return;
        if (typeof x === 'string' && isUrl(x)) urls.add(x);
        else if (Array.isArray(x)) x.forEach(walker2);
        else if (typeof x === 'object') for (const k in x) walker2(x[k]);
      }
      walker2(obj);
    }
    return Array.from(urls);
  }

  // download Blob and auto click <a>
  function saveBlob(blob, filename = 'video.mp4') {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  // attempt to fetch remote file as blob (CORS-sensitive)
  async function fetchAsBlob(fileUrl, onProgress) {
    // Try using fetch() with streaming to show some progress if possible
    const resp = await fetch(fileUrl);
    if (!resp.ok) throw new Error('Failed to fetch file: ' + resp.status);
    // If response is opaque (no-cors) the blob is inaccessible
    if (resp.type === 'opaque') throw new Error('Opaque response (likely blocked by CORS).');
    const contentDisposition = resp.headers.get('content-disposition');
    const contentType = resp.headers.get('content-type') || 'application/octet-stream';
    const total = parseInt(resp.headers.get('content-length') || '0', 10);

    // If the body has a readable stream, we could implement progress. Keep it simple:
    const blob = await resp.blob();
    return { blob, contentDisposition, contentType, total };
  }

  // fallback: try axios to download as blob (same CORS restrictions)
  async function axiosBlob(url) {
    const r = await axios.get(url, { responseType: 'blob' });
    return { blob: r.data, headers: r.headers || {} };
  }

  // MAIN: call RapidAPI, detect media URL(s), attempt blob download
  async function handleDownload() {
    const input = document.getElementById('url');
    const rawOut = document.getElementById('debug');
    const resultWr = document.getElementById('result');
    const mediaArea = document.getElementById('mediaArea');
    resultWr.style.display = 'none';
    mediaArea.innerHTML = '';
    setStatus('Fetching info from API...');

    const userUrl = input.value.trim();
    if (!userUrl) { setStatus('Enter an Instagram URL first', true); return; }

    // 1) Call RapidAPI (same as your snippet)
    try {
      const options = {
        method: 'GET',
        url: RAPIDAPI_ENDPOINT,
        params: { url: userUrl },
        headers: {
          'x-rapidapi-key': RAPIDAPI_KEY,
          'x-rapidapi-host': RAPIDAPI_HOST
        },
        timeout: 20000
      };

      const res = await axios.request(options);
      rawOut.textContent = pretty(res.data);
      console.log('API response:', res.data);

      // 2) Extract candidate URLs from the API response
      const candidates = extractUrls(res.data);
      console.log('candidates found:', candidates);

      if (!candidates || candidates.length === 0) {
        setStatus('No media URL found in API response.', true);
        resultWr.style.display = 'block';
        document.getElementById('raw').innerHTML = '<small>Raw JSON:</small><pre>' + pretty(res.data) + '</pre>';
        return;
      }

      // pick the most likely candidate (prefer mp4)
      let fileUrl = candidates.find(u => /\.mp4(\?|$)/i.test(u)) || candidates[0];
      setStatus('Found media URL — attempting automatic download...');

      // show preview if it is playable
      if (/\.mp4(\?|$)/i.test(fileUrl) || /video/i.test(fileUrl)) {
        const thumb = extractUrls(res.data).find(u => /\.(jpe?g|png|webp)/i.test(u));
        mediaArea.innerHTML = `
          <div class="flex">
            ${thumb ? `<img class="thumb" src="${thumb}" alt="thumb">` : ''}
            <div>
              <div><strong>Detected media URL:</strong></div>
              <div style="word-break:break-all"><small>${fileUrl}</small></div>
              <div class="note">If automatic download fails, use the fallback link below.</div>
            </div>
          </div>
        `;
      }

      // 3) Try fetch->blob -> save
      try {
        setStatus('Downloading file (fetching blob)...');
        const { blob } = await fetchAsBlob(fileUrl);
        setStatus('Saving file...');
        // Derive filename
        const name = (new URL(fileUrl).pathname.split('/').pop() || 'instagram-video.mp4').split('?')[0];
        saveBlob(blob, name);
        setStatus('✅ Download started (blob).');
        resultWr.style.display = 'block';
        document.getElementById('raw').innerHTML = '<small>Raw JSON:</small><pre>' + pretty(res.data) + '</pre>';
        return;
      } catch (errFetch) {
        console.warn('fetch blob failed:', errFetch);
        // try axios fallback
        try {
          setStatus('fetch failed (likely CORS). Trying axios blob fallback...');
          const { blob } = await axiosBlob(fileUrl);
          const name = (new URL(fileUrl).pathname.split('/').pop() || 'instagram-video.mp4').split('?')[0];
          saveBlob(blob, name);
          setStatus('✅ Download started (axios blob).');
          resultWr.style.display = 'block';
          document.getElementById('raw').innerHTML = '<small>Raw JSON:</small><pre>' + pretty(res.data) + '</pre>';
          return;
        } catch (errAxios) {
          console.warn('axios blob failed:', errAxios);
          // Final fallback: show direct link
          setStatus('Automatic download blocked by CORS — showing fallback link.', true);
          resultWr.style.display = 'block';
          mediaArea.innerHTML += `
            <div style="margin-top:10px">
              <a class="fallback" href="${fileUrl}" target="_blank" rel="noopener">Open direct link (right-click → Save as)</a>
            </div>
            <div class="note">If you want automatic downloads without CORS problems, use the small proxy example below.</div>
            <hr/>
            <div><strong>Proxy snippet (Cloudflare Worker) — use to proxy video URL and force download:</strong></div>
            <pre style="white-space:pre-wrap;background:#222;color:#dff;padding:8px;border-radius:6px;">
addEventListener('fetch', event =&gt; {
  const url = new URL(event.request.url);
  const target = url.searchParams.get('u');
  if (!target) return event.respondWith(new Response('Missing u param', { status: 400 }));
  return event.respondWith(fetch(target).then(r =&gt; {
    const headers = new Headers(r.headers);
    headers.set('Access-Control-Allow-Origin','*');
    headers.set('Content-Disposition','attachment; filename=\"video.mp4\"');
    return new Response(r.body, { status: r.status, statusText: r.statusText, headers });
  }).catch(err =&gt; new Response(err.message, { status: 502 })));
});
            </pre>
            <div class="note">Then call: <code>https://your-worker.example.com/?u=ENCODED_VIDEO_URL</code></div>
          `;
          document.getElementById('raw').innerHTML = '<small>Raw JSON:</small><pre>' + pretty(res.data) + '</pre>';
          return;
        }
      }
    } catch (err) {
      console.error('API call failed', err);
      setStatus('API request failed. See console for details.', true);
      document.getElementById('debug').textContent = (err && err.response && err.response.data) ? pretty(err.response.data) : String(err);
    }
  }

  // Wire up buttons
  document.getElementById('btn').addEventListener('click', handleDownload);
  document.getElementById('clear').addEventListener('click', () => {
    document.getElementById('url').value = '';
    document.getElementById('status').textContent = '';
    document.getElementById('debug').textContent = '{}';
    document.getElementById('result').style.display = 'none';
  });
  </script>
</body>
</html>
